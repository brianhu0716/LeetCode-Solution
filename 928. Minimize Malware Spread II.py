# -*- coding: utf-8 -*-
"""
Created on Mon May 10 00:03:44 2021

@author: Brian
"""

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        def dfs(infected_list):                     
            for index in infected_list : 
                for idx_connection in range(len(graph[index])):
                    isconnected = graph[index][idx_connection]
                    # 散布病毒的node與當前node有連結、當前node沒有出現在已被感染的路徑中、連結的node不是自帶病毒者
                    if isconnected == 1 and idx_connection not in infected_list and idx_connection not in initial: 
                        infected_list.append(idx_connection)
                        counter[idx_connection] = counter.get(idx_connection,0) + 1
            return infected_list

        
        counter = {}
        table = []
        
        for source in initial:
            infected_list = dfs([source]) # infected_list為被當前source感染的node index
            
            table += [[source,infected_list]]

        #print(table) 
        #print(counter)
        total_infected = len(counter.keys())
        ans = []
        for source,infected_list in table:
            n = 0 # 可以被移除的node數量
            # 注意：排除唯一透過當前source所感然的node時，不代表當前的source可以被排除(只是他與其他人的連結斷開，但source依然是被感染狀態)
            for node in infected_list[1 : ]: # source不可以被算在移除的數量中
                # node被感染一次且又出現在當前的source路徑中，表示當node可以透過移除當前source與其他node的連結，避免感染該node
                if counter[node] == 1 : 
                    n += 1
            ans += [[total_infected - n,source]]  # total_infected - n代表移除source的感然node數後，剩餘依舊是感染狀態的node數                 
        #print(ans)
        return sorted(ans)[0][1]